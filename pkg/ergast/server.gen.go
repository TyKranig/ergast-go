// Package ergast provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package ergast

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Circuit defines model for Circuit.
type Circuit struct {
	Location *struct {
		Country  *string `json:"country,omitempty"`
		Lat      *string `json:"lat,omitempty"`
		Locality *string `json:"locality,omitempty"`
		Long     *string `json:"long,omitempty"`
	} `json:"Location,omitempty"`
	CircuitId   *string `json:"circuitId,omitempty"`
	CircuitName *string `json:"circuitName,omitempty"`
	Round       *string `json:"round,omitempty"`
	Url         *string `json:"url,omitempty"`
}

// Constructor defines model for Constructor.
type Constructor struct {
	ConstructorId *string `json:"constructorId,omitempty"`
	Name          *string `json:"name,omitempty"`
	Nationality   *string `json:"nationality,omitempty"`
	Url           *string `json:"url,omitempty"`
}

// ConstructorStandingsByYearResponse defines model for ConstructorStandingsByYearResponse.
type ConstructorStandingsByYearResponse struct {
	MRData *struct {
		StandingsTable *struct {
			StandingsLists *[]struct {
				ConstructorStandings *[]struct {
					Constructor  *Constructor `json:"Constructor,omitempty"`
					Points       *string      `json:"points,omitempty"`
					Position     *string      `json:"position,omitempty"`
					PositionText *string      `json:"positionText,omitempty"`
					Wins         *string      `json:"wins,omitempty"`
				} `json:"ConstructorStandings,omitempty"`
				Round  *string `json:"round,omitempty"`
				Season *string `json:"season,omitempty"`
			} `json:"StandingsLists,omitempty"`
			Season *string `json:"season,omitempty"`
		} `json:"StandingsTable,omitempty"`
		Limit  *string `json:"limit,omitempty"`
		Offset *string `json:"offset,omitempty"`
		Series *string `json:"series,omitempty"`
		Total  *string `json:"total,omitempty"`
		Url    *string `json:"url,omitempty"`
		Xmlns  *string `json:"xmlns,omitempty"`
	} `json:"MRData,omitempty"`
}

// ConstructorsByYearResponse defines model for ConstructorsByYearResponse.
type ConstructorsByYearResponse struct {
	MRData *struct {
		ConstructorTable *struct {
			Constructors *[]Constructor `json:"Constructors,omitempty"`
			Season       *string        `json:"season,omitempty"`
		} `json:"ConstructorTable,omitempty"`
		Limit  *string `json:"limit,omitempty"`
		Offset *string `json:"offset,omitempty"`
		Series *string `json:"series,omitempty"`
		Total  *string `json:"total,omitempty"`
		Url    *string `json:"url,omitempty"`
		Xmlns  *string `json:"xmlns,omitempty"`
	} `json:"MRData,omitempty"`
}

// Driver defines model for Driver.
type Driver struct {
	Code            *string `json:"code,omitempty"`
	DateOfBirth     *string `json:"dateOfBirth,omitempty"`
	DriverId        *string `json:"driverId,omitempty"`
	FamilyName      *string `json:"familyName,omitempty"`
	GivenName       *string `json:"givenName,omitempty"`
	Nationality     *string `json:"nationality,omitempty"`
	PermanentNumber *string `json:"permanentNumber,omitempty"`
	Url             *string `json:"url,omitempty"`
}

// DriverStandingsByYearResponse defines model for DriverStandingsByYearResponse.
type DriverStandingsByYearResponse struct {
	MRData *struct {
		StandingsTable *struct {
			StandingsLists *[]struct {
				DriverStandings *[]struct {
					Constructors *[]Constructor `json:"Constructors,omitempty"`
					Driver       *Driver        `json:"Driver,omitempty"`
					Points       *string        `json:"points,omitempty"`
					Position     *string        `json:"position,omitempty"`
					PositionText *string        `json:"positionText,omitempty"`
					Wins         *string        `json:"wins,omitempty"`
				} `json:"DriverStandings,omitempty"`
				Round  *string `json:"round,omitempty"`
				Season *string `json:"season,omitempty"`
			} `json:"StandingsLists,omitempty"`
			Season *string `json:"season,omitempty"`
		} `json:"StandingsTable,omitempty"`
		Limit  *string `json:"limit,omitempty"`
		Offset *string `json:"offset,omitempty"`
		Series *string `json:"series,omitempty"`
		Total  *string `json:"total,omitempty"`
		Url    *string `json:"url,omitempty"`
		Xmlns  *string `json:"xmlns,omitempty"`
	} `json:"MRData,omitempty"`
}

// DriversResponse defines model for DriversResponse.
type DriversResponse struct {
	MRData *struct {
		DriverTable *struct {
			Drivers *[]Driver `json:"Drivers,omitempty"`
		} `json:"DriverTable,omitempty"`
		Limit  *string `json:"limit,omitempty"`
		Offset *string `json:"offset,omitempty"`
		Series *string `json:"series,omitempty"`
		Total  *string `json:"total,omitempty"`
		Url    *string `json:"url,omitempty"`
		Xmlns  *string `json:"xmlns,omitempty"`
	} `json:"MRData,omitempty"`
}

// Race defines model for Race.
type Race struct {
	Circuit  *Circuit  `json:"Circuit,omitempty"`
	Results  *[]Result `json:"Results,omitempty"`
	Date     *string   `json:"date,omitempty"`
	RaceName *string   `json:"raceName,omitempty"`
	Round    *string   `json:"round,omitempty"`
	Season   *string   `json:"season,omitempty"`
	Time     *string   `json:"time,omitempty"`
	Url      *string   `json:"url,omitempty"`
}

// Result defines model for Result.
type Result struct {
	Constructor *Constructor `json:"Constructor,omitempty"`
	Driver      *Driver      `json:"Driver,omitempty"`
	FastestLap  *struct {
		AverageSpeed *struct {
			Speed *string `json:"speed,omitempty"`
			Units *string `json:"units,omitempty"`
		} `json:"AverageSpeed,omitempty"`
		Time *struct {
			Time *string `json:"time,omitempty"`
		} `json:"Time,omitempty"`
		Lap  *string `json:"lap,omitempty"`
		Rank *string `json:"rank,omitempty"`
	} `json:"FastestLap,omitempty"`
	Time *struct {
		Millis *string `json:"millis,omitempty"`
		Time   *string `json:"time,omitempty"`
	} `json:"Time,omitempty"`
	Grid         *string `json:"grid,omitempty"`
	Laps         *string `json:"laps,omitempty"`
	Number       *string `json:"number,omitempty"`
	Points       *string `json:"points,omitempty"`
	Position     *string `json:"position,omitempty"`
	PositionText *string `json:"positionText,omitempty"`
	Status       *string `json:"status,omitempty"`
}

// ResultsByYearResponse defines model for ResultsByYearResponse.
type ResultsByYearResponse struct {
	MRData *struct {
		RaceTable *struct {
			Races *[]Race `json:"Races,omitempty"`

			// Round Only returned if round parameter used
			Round  *string `json:"round,omitempty"`
			Season *string `json:"season,omitempty"`
		} `json:"RaceTable,omitempty"`
		Limit  *string `json:"limit,omitempty"`
		Offset *string `json:"offset,omitempty"`
		Series *string `json:"series,omitempty"`
		Total  *string `json:"total,omitempty"`
		Url    *string `json:"url,omitempty"`
		Xmlns  *string `json:"xmlns,omitempty"`
	} `json:"MRData,omitempty"`
}

// SeasonByYearResponse defines model for SeasonByYearResponse.
type SeasonByYearResponse struct {
	MRData *struct {
		RaceTable *struct {
			Races  *[]Race `json:"Races,omitempty"`
			Season *string `json:"season,omitempty"`
		} `json:"RaceTable,omitempty"`
		Limit  *string `json:"limit,omitempty"`
		Offset *string `json:"offset,omitempty"`
		Series *string `json:"series,omitempty"`
		Total  *string `json:"total,omitempty"`
		Url    *string `json:"url,omitempty"`
		Xmlns  *string `json:"xmlns,omitempty"`
	} `json:"MRData,omitempty"`
}

// ConstructorParam defines model for constructorParam.
type ConstructorParam = string

// LimitParam defines model for limitParam.
type LimitParam = int

// OffsetParam defines model for offsetParam.
type OffsetParam = int

// RoundParam defines model for roundParam.
type RoundParam = string

// YearParam defines model for yearParam.
type YearParam = string

// GetSeasonByYearParams defines parameters for GetSeasonByYear.
type GetSeasonByYearParams struct {
	// Offset The number of items to skip before starting to collect the result set.
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The numbers of items to return.
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetConstructorStandingsByYearParams defines parameters for GetConstructorStandingsByYear.
type GetConstructorStandingsByYearParams struct {
	// Offset The number of items to skip before starting to collect the result set.
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The numbers of items to return.
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetConstructorsByYearParams defines parameters for GetConstructorsByYear.
type GetConstructorsByYearParams struct {
	// Offset The number of items to skip before starting to collect the result set.
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The numbers of items to return.
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetResultsByYearAndConstructorParams defines parameters for GetResultsByYearAndConstructor.
type GetResultsByYearAndConstructorParams struct {
	// Offset The number of items to skip before starting to collect the result set.
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The numbers of items to return.
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetDriverStandingsByYearParams defines parameters for GetDriverStandingsByYear.
type GetDriverStandingsByYearParams struct {
	// Offset The number of items to skip before starting to collect the result set.
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The numbers of items to return.
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetResultsByYearParams defines parameters for GetResultsByYear.
type GetResultsByYearParams struct {
	// Offset The number of items to skip before starting to collect the result set.
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The numbers of items to return.
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetResultsByYearAndRoundParams defines parameters for GetResultsByYearAndRound.
type GetResultsByYearAndRoundParams struct {
	// Offset The number of items to skip before starting to collect the result set.
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The numbers of items to return.
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllDrivers request
	GetAllDrivers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeasonByYear request
	GetSeasonByYear(ctx context.Context, year YearParam, params *GetSeasonByYearParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConstructorStandingsByYear request
	GetConstructorStandingsByYear(ctx context.Context, year YearParam, params *GetConstructorStandingsByYearParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConstructorsByYear request
	GetConstructorsByYear(ctx context.Context, year YearParam, params *GetConstructorsByYearParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResultsByYearAndConstructor request
	GetResultsByYearAndConstructor(ctx context.Context, year YearParam, constructorId ConstructorParam, params *GetResultsByYearAndConstructorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDriverStandingsByYear request
	GetDriverStandingsByYear(ctx context.Context, year YearParam, params *GetDriverStandingsByYearParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDriversByYear request
	GetDriversByYear(ctx context.Context, year YearParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResultsByYear request
	GetResultsByYear(ctx context.Context, year YearParam, params *GetResultsByYearParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResultsByYearAndRound request
	GetResultsByYearAndRound(ctx context.Context, year YearParam, round RoundParam, params *GetResultsByYearAndRoundParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAllDrivers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllDriversRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeasonByYear(ctx context.Context, year YearParam, params *GetSeasonByYearParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeasonByYearRequest(c.Server, year, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConstructorStandingsByYear(ctx context.Context, year YearParam, params *GetConstructorStandingsByYearParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConstructorStandingsByYearRequest(c.Server, year, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConstructorsByYear(ctx context.Context, year YearParam, params *GetConstructorsByYearParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConstructorsByYearRequest(c.Server, year, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResultsByYearAndConstructor(ctx context.Context, year YearParam, constructorId ConstructorParam, params *GetResultsByYearAndConstructorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResultsByYearAndConstructorRequest(c.Server, year, constructorId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDriverStandingsByYear(ctx context.Context, year YearParam, params *GetDriverStandingsByYearParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDriverStandingsByYearRequest(c.Server, year, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDriversByYear(ctx context.Context, year YearParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDriversByYearRequest(c.Server, year)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResultsByYear(ctx context.Context, year YearParam, params *GetResultsByYearParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResultsByYearRequest(c.Server, year, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResultsByYearAndRound(ctx context.Context, year YearParam, round RoundParam, params *GetResultsByYearAndRoundParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResultsByYearAndRoundRequest(c.Server, year, round, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllDriversRequest generates requests for GetAllDrivers
func NewGetAllDriversRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/drivers.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeasonByYearRequest generates requests for GetSeasonByYear
func NewGetSeasonByYearRequest(server string, year YearParam, params *GetSeasonByYearParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConstructorStandingsByYearRequest generates requests for GetConstructorStandingsByYear
func NewGetConstructorStandingsByYearRequest(server string, year YearParam, params *GetConstructorStandingsByYearParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/constructorStandings.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConstructorsByYearRequest generates requests for GetConstructorsByYear
func NewGetConstructorsByYearRequest(server string, year YearParam, params *GetConstructorsByYearParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/constructors.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResultsByYearAndConstructorRequest generates requests for GetResultsByYearAndConstructor
func NewGetResultsByYearAndConstructorRequest(server string, year YearParam, constructorId ConstructorParam, params *GetResultsByYearAndConstructorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "constructorId", runtime.ParamLocationPath, constructorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/constructors/%s/results.json", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDriverStandingsByYearRequest generates requests for GetDriverStandingsByYear
func NewGetDriverStandingsByYearRequest(server string, year YearParam, params *GetDriverStandingsByYearParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/driverStandings.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDriversByYearRequest generates requests for GetDriversByYear
func NewGetDriversByYearRequest(server string, year YearParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/drivers.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResultsByYearRequest generates requests for GetResultsByYear
func NewGetResultsByYearRequest(server string, year YearParam, params *GetResultsByYearParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/results.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResultsByYearAndRoundRequest generates requests for GetResultsByYearAndRound
func NewGetResultsByYearAndRoundRequest(server string, year YearParam, round RoundParam, params *GetResultsByYearAndRoundParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "round", runtime.ParamLocationPath, round)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/%s/results.json", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllDrivers request
	GetAllDriversWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllDriversResponse, error)

	// GetSeasonByYear request
	GetSeasonByYearWithResponse(ctx context.Context, year YearParam, params *GetSeasonByYearParams, reqEditors ...RequestEditorFn) (*GetSeasonByYearResponse, error)

	// GetConstructorStandingsByYear request
	GetConstructorStandingsByYearWithResponse(ctx context.Context, year YearParam, params *GetConstructorStandingsByYearParams, reqEditors ...RequestEditorFn) (*GetConstructorStandingsByYearResponse, error)

	// GetConstructorsByYear request
	GetConstructorsByYearWithResponse(ctx context.Context, year YearParam, params *GetConstructorsByYearParams, reqEditors ...RequestEditorFn) (*GetConstructorsByYearResponse, error)

	// GetResultsByYearAndConstructor request
	GetResultsByYearAndConstructorWithResponse(ctx context.Context, year YearParam, constructorId ConstructorParam, params *GetResultsByYearAndConstructorParams, reqEditors ...RequestEditorFn) (*GetResultsByYearAndConstructorResponse, error)

	// GetDriverStandingsByYear request
	GetDriverStandingsByYearWithResponse(ctx context.Context, year YearParam, params *GetDriverStandingsByYearParams, reqEditors ...RequestEditorFn) (*GetDriverStandingsByYearResponse, error)

	// GetDriversByYear request
	GetDriversByYearWithResponse(ctx context.Context, year YearParam, reqEditors ...RequestEditorFn) (*GetDriversByYearResponse, error)

	// GetResultsByYear request
	GetResultsByYearWithResponse(ctx context.Context, year YearParam, params *GetResultsByYearParams, reqEditors ...RequestEditorFn) (*GetResultsByYearResponse, error)

	// GetResultsByYearAndRound request
	GetResultsByYearAndRoundWithResponse(ctx context.Context, year YearParam, round RoundParam, params *GetResultsByYearAndRoundParams, reqEditors ...RequestEditorFn) (*GetResultsByYearAndRoundResponse, error)
}

type GetAllDriversResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DriversResponse
}

// Status returns HTTPResponse.Status
func (r GetAllDriversResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllDriversResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeasonByYearResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SeasonByYearResponse
}

// Status returns HTTPResponse.Status
func (r GetSeasonByYearResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeasonByYearResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConstructorStandingsByYearResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConstructorStandingsByYearResponse
}

// Status returns HTTPResponse.Status
func (r GetConstructorStandingsByYearResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConstructorStandingsByYearResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConstructorsByYearResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConstructorsByYearResponse
}

// Status returns HTTPResponse.Status
func (r GetConstructorsByYearResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConstructorsByYearResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResultsByYearAndConstructorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResultsByYearResponse
}

// Status returns HTTPResponse.Status
func (r GetResultsByYearAndConstructorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResultsByYearAndConstructorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDriverStandingsByYearResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DriverStandingsByYearResponse
}

// Status returns HTTPResponse.Status
func (r GetDriverStandingsByYearResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDriverStandingsByYearResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDriversByYearResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DriversResponse
}

// Status returns HTTPResponse.Status
func (r GetDriversByYearResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDriversByYearResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResultsByYearResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResultsByYearResponse
}

// Status returns HTTPResponse.Status
func (r GetResultsByYearResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResultsByYearResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResultsByYearAndRoundResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResultsByYearResponse
}

// Status returns HTTPResponse.Status
func (r GetResultsByYearAndRoundResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResultsByYearAndRoundResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllDriversWithResponse request returning *GetAllDriversResponse
func (c *ClientWithResponses) GetAllDriversWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllDriversResponse, error) {
	rsp, err := c.GetAllDrivers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllDriversResponse(rsp)
}

// GetSeasonByYearWithResponse request returning *GetSeasonByYearResponse
func (c *ClientWithResponses) GetSeasonByYearWithResponse(ctx context.Context, year YearParam, params *GetSeasonByYearParams, reqEditors ...RequestEditorFn) (*GetSeasonByYearResponse, error) {
	rsp, err := c.GetSeasonByYear(ctx, year, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeasonByYearResponse(rsp)
}

// GetConstructorStandingsByYearWithResponse request returning *GetConstructorStandingsByYearResponse
func (c *ClientWithResponses) GetConstructorStandingsByYearWithResponse(ctx context.Context, year YearParam, params *GetConstructorStandingsByYearParams, reqEditors ...RequestEditorFn) (*GetConstructorStandingsByYearResponse, error) {
	rsp, err := c.GetConstructorStandingsByYear(ctx, year, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConstructorStandingsByYearResponse(rsp)
}

// GetConstructorsByYearWithResponse request returning *GetConstructorsByYearResponse
func (c *ClientWithResponses) GetConstructorsByYearWithResponse(ctx context.Context, year YearParam, params *GetConstructorsByYearParams, reqEditors ...RequestEditorFn) (*GetConstructorsByYearResponse, error) {
	rsp, err := c.GetConstructorsByYear(ctx, year, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConstructorsByYearResponse(rsp)
}

// GetResultsByYearAndConstructorWithResponse request returning *GetResultsByYearAndConstructorResponse
func (c *ClientWithResponses) GetResultsByYearAndConstructorWithResponse(ctx context.Context, year YearParam, constructorId ConstructorParam, params *GetResultsByYearAndConstructorParams, reqEditors ...RequestEditorFn) (*GetResultsByYearAndConstructorResponse, error) {
	rsp, err := c.GetResultsByYearAndConstructor(ctx, year, constructorId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResultsByYearAndConstructorResponse(rsp)
}

// GetDriverStandingsByYearWithResponse request returning *GetDriverStandingsByYearResponse
func (c *ClientWithResponses) GetDriverStandingsByYearWithResponse(ctx context.Context, year YearParam, params *GetDriverStandingsByYearParams, reqEditors ...RequestEditorFn) (*GetDriverStandingsByYearResponse, error) {
	rsp, err := c.GetDriverStandingsByYear(ctx, year, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDriverStandingsByYearResponse(rsp)
}

// GetDriversByYearWithResponse request returning *GetDriversByYearResponse
func (c *ClientWithResponses) GetDriversByYearWithResponse(ctx context.Context, year YearParam, reqEditors ...RequestEditorFn) (*GetDriversByYearResponse, error) {
	rsp, err := c.GetDriversByYear(ctx, year, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDriversByYearResponse(rsp)
}

// GetResultsByYearWithResponse request returning *GetResultsByYearResponse
func (c *ClientWithResponses) GetResultsByYearWithResponse(ctx context.Context, year YearParam, params *GetResultsByYearParams, reqEditors ...RequestEditorFn) (*GetResultsByYearResponse, error) {
	rsp, err := c.GetResultsByYear(ctx, year, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResultsByYearResponse(rsp)
}

// GetResultsByYearAndRoundWithResponse request returning *GetResultsByYearAndRoundResponse
func (c *ClientWithResponses) GetResultsByYearAndRoundWithResponse(ctx context.Context, year YearParam, round RoundParam, params *GetResultsByYearAndRoundParams, reqEditors ...RequestEditorFn) (*GetResultsByYearAndRoundResponse, error) {
	rsp, err := c.GetResultsByYearAndRound(ctx, year, round, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResultsByYearAndRoundResponse(rsp)
}

// ParseGetAllDriversResponse parses an HTTP response from a GetAllDriversWithResponse call
func ParseGetAllDriversResponse(rsp *http.Response) (*GetAllDriversResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllDriversResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DriversResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeasonByYearResponse parses an HTTP response from a GetSeasonByYearWithResponse call
func ParseGetSeasonByYearResponse(rsp *http.Response) (*GetSeasonByYearResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeasonByYearResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SeasonByYearResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConstructorStandingsByYearResponse parses an HTTP response from a GetConstructorStandingsByYearWithResponse call
func ParseGetConstructorStandingsByYearResponse(rsp *http.Response) (*GetConstructorStandingsByYearResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConstructorStandingsByYearResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConstructorStandingsByYearResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConstructorsByYearResponse parses an HTTP response from a GetConstructorsByYearWithResponse call
func ParseGetConstructorsByYearResponse(rsp *http.Response) (*GetConstructorsByYearResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConstructorsByYearResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConstructorsByYearResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResultsByYearAndConstructorResponse parses an HTTP response from a GetResultsByYearAndConstructorWithResponse call
func ParseGetResultsByYearAndConstructorResponse(rsp *http.Response) (*GetResultsByYearAndConstructorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResultsByYearAndConstructorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsByYearResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDriverStandingsByYearResponse parses an HTTP response from a GetDriverStandingsByYearWithResponse call
func ParseGetDriverStandingsByYearResponse(rsp *http.Response) (*GetDriverStandingsByYearResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDriverStandingsByYearResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DriverStandingsByYearResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDriversByYearResponse parses an HTTP response from a GetDriversByYearWithResponse call
func ParseGetDriversByYearResponse(rsp *http.Response) (*GetDriversByYearResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDriversByYearResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DriversResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResultsByYearResponse parses an HTTP response from a GetResultsByYearWithResponse call
func ParseGetResultsByYearResponse(rsp *http.Response) (*GetResultsByYearResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResultsByYearResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsByYearResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResultsByYearAndRoundResponse parses an HTTP response from a GetResultsByYearAndRoundWithResponse call
func ParseGetResultsByYearAndRoundResponse(rsp *http.Response) (*GetResultsByYearAndRoundResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResultsByYearAndRoundResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsByYearResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
